[{"content":" First, here are some references for PyTorch:\nPyTorch Official Documentation Dive into Deep Learning Some Example Code and Explanations # import torch as pt x = pt.arange(12) print(x) X = x.reshape(3,4) # Equivalent to the next line (specify one dimension and automatically calculate the other) XX = x.reshape(-1,4) pt.zeros(2,3,4,5) # Create a four-dimensional tensor of zeros x = pt.randn(3,4) # Random tensor from a normal distribution y = pt.randn(3,4) pt.tensor([[1,2,3,4],[2,1,4,3],[4,3,5,2]]) # Manually input a 2D tensor addd = x + y # Element-wise addition subb = x - y mutt = x * y divw = x / y poww = x ** y expp = pt.exp(x) rcat = pt.cat((x,y),dim=0) # Concatenate along rows, dim=1 concatenates along columns x == y # Check if the values at corresponding positions in two matrices are equal and output a boolean matrix x.sum() # Sum all values in the tensor The broadcasting mechanism is used to perform element-wise operations. The mechanism works as follows:\nThe arrays are extended by copying the elements appropriately so that, after the transformation, the two tensors have the same shape. Element-wise operations are performed on the resulting arrays. PyTorch constructs a computational graph based on the designed model to perform automatic differentiation and calculate gradients, and then performs backpropagation to update the parameters.\n","date":"20 April 2023","permalink":"/machine-learning/pytorch-preliminary/","section":"机器学习","summary":"Fundamental knowledge of PyTorch","title":"Fundamental Knowledge of PyTorch"},{"content":"","date":null,"permalink":"/tags/machine-learning/","section":"Tags","summary":"","title":"Machine Learning"},{"content":"\n\n","date":"20 April 2023","permalink":"/machine-learning/pytorch-preliminary/","section":"机器学习","summary":"Some fundamental knowledge of PyTorch","title":"Summary of Common Deep Learning Models"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/","section":"Welcome to Congo! ","summary":"","title":"Welcome to Congo! "},{"content":"","date":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习"},{"content":"深度学习和机器学习相关。 聚类算法，SVM，生成对抗网络，决策树，回归方法，集成学习，贝叶斯分类器，降维和度量学习，计算学习理论，各类梯度下降法\n","date":null,"permalink":"/machine-learning/","section":"机器学习","summary":"深度学习和机器学习相关。 聚类算法，SVM，生成对抗网络，决策树，回归方法，集成学习，贝叶斯分类器，降维和度量学习，计算学习理论，各类梯度下降法","title":"机器学习"},{"content":"\n\n","date":"20 April 2023","permalink":"/optimization/ml-opt-algo/","section":"运筹优化","summary":"","title":"机器学习常用优化算法"},{"content":"优化理论，包括凸优化、非凸优化等等等等。\n想写的东西（提纲） 最优化算法： ADMM，KKT条件，牛顿法，拟牛顿法，线搜索法，信赖域法，共轭梯度法，增广拉格朗日乘子法，拉格朗日乘子法，线性优化算法，启发式算法，次梯度法，罚函数法，随机坐标下降法，原对偶法 序列线性规划算法，序列二次规划算法，Franke-Wolfe 算法， 运筹概念……线性规划和单纯形法，整数规划，内点法，运输和指派问题，元启发式算法，TSP/VRP问题，整数规划，分支定界法，\n","date":null,"permalink":"/optimization/","section":"运筹优化","summary":"优化理论，包括凸优化、非凸优化等等等等。","title":"运筹优化"},{"content":"Learning data structure and algorithms……\nP.S. Mostly in Java and Python.\nThis section includes some summaries on data structures, and introducing some classic algorithms, such as greedy, divide and conquer, dynamic programming, etc.\n","date":null,"permalink":"/algorithm/","section":"Algorithms","summary":"Learning data structure and algorithms……","title":"Algorithms"},{"content":"Quick Start Notes on Regular Expressions # The following content is derived from RegexOne, a quick start tutorial for regular expressions that allows practicing on their website. Here are quick start notes and a reference cheat sheet for regular expressions. %%%\nExample Description abc\u0026hellip; Letters 123\u0026hellip; Digits \\d Any Digit \\D Any Non-digit character . Any Character . Period [abc] Only a, b, or c [^abc] Not a, b, nor c [a-z] Characters a to z [0-9] Numbers 0 to 9 \\w Any Alphanumeric character \\W Any Non-alphanumeric character {m} m Repetitions {m,n} m to n Repetitions * Zero or more repetitions + One or more repetitions ? Optional character \\s Any Whitespace \\S Any Non-whitespace character ^…$ Starts and ends (…) Capture Group (a(bc)) Capture Sub-group (.*) Capture all (abc|def) Matches abc or def ","date":"10 April 2023","permalink":"/algorithm/regex-notes/","section":"Algorithms","summary":"A quick start guide to regular expressions","title":"Quick Start to Regular Expressions"},{"content":"","date":null,"permalink":"/tags/regular-expressions/","section":"Tags","summary":"","title":"Regular Expressions"},{"content":" This article provides a step-by-step guide to installing Tensorflow on MacOS for Apple Silicon.\nPrerequisites # Before installing Tensorflow, you need to install xcode command line tools. You can install it by entering the following command in the terminal:\nxcode-select --install In addition, this tutorial is based on Anaconda, but you can also create a virtual environment using Miniconda or Virtualenv. You can download and install Anaconda from here. Please find the appropriate version and follow the installation instructions on the official website. The installation process will not be repeated here. After installing Anaconda, Python can be used directly. However, if you want to use conda to create a virtual environment, you need to initialize conda by entering the following command in the terminal:\nconda init Installing Tensorflow and Tensorflow Metal # First, create a virtual environment based on Python 3.8:\nconda create -n tensorflow python=3.8 Then, activate the virtual environment:\nconda activate tensorflow Install the dependencies for Tensorflow and Tensorflow Metal:\nconda install -c apple tensorflow-deps If you encounter any issues with finding the installation package, add the following command to the .condarc file in your user folder to enable installation:\nsubdirs: - osx-arm64 Next, based on the versions of tensorflow-macos and tensorflow-metal listed in the table at the bottom of the official website\u0026rsquo;s Get started with tensorflow-metal page, use the following command to install Tensorflow and the Tensorflow Metal plugin (the metal plugin enables GPU acceleration for machine learning):\npython -m pip install tensorflow-macos==2.9 tensorflow-metal==0.5.0 Testing the Installation # If you also need to install Jupyter Notebook, you can use the following command:\nconda install -c conda-forge -y jupyter You can use the following script to test and run Tensorflow (or you can use the code from the official website):\nimport tensorflow as tf print(tf.__version__) print(tf.config.list_physical_devices(\u0026#39;GPU\u0026#39;)) If the output is:\n2.9.0 [PhysicalDevice(name=\u0026#39;/physical_device:GPU:0\u0026#39;, device_type=\u0026#39;GPU\u0026#39;)] Congratulations! You have successfully installed Tensorflow and Tensorflow Metal on Apple Silicon. Have fun!\nReferences: Get started with tensorflow-metal\n","date":"31 March 2023","permalink":"/machine-learning/macos-tf-install/","section":"机器学习","summary":"Step-by-step guide to installing Tensorflow on MacOS for Apple Silicon","title":"MacOS Tensorflow Installation Guide (For Apple Silicon)"},{"content":"","date":null,"permalink":"/tags/algorithms/","section":"Tags","summary":"","title":"Algorithms"},{"content":" Under Construction There are numerous sorting algorithms, and this article will introduce ten popular and commonly used sorting algorithms, including bubble sort, insertion sort, selection sort, merge sort, quicksort, heap sort, counting sort, bucket sort, radix sort, and shell sort, among others. However, please note that this article serves as a brief overview and implementation of these algorithms, and for more detailed information, you can refer to the \u0026ldquo;Sorting Algorithms\u0026rdquo; section on the Runoob tutorial website here.\nBubble Sort # Insertion Sort # Selection Sort # Merge Sort # Quick Sort # Heap Sort # Counting Sort # Bucket Sort # Radix Sort # Shell Sort # ","date":"28 March 2023","permalink":"/algorithm/sorting/","section":"Algorithms","summary":"Under Construction There are numerous sorting algorithms, and this article will introduce ten popular and commonly used sorting algorithms, including bubble sort, insertion sort, selection sort, merge sort, quicksort, heap sort, counting sort, bucket sort, radix sort, and shell sort, among others.","title":"Sorting Algorithms"},{"content":" Binary search is an algorithm with a time complexity of \\(O(\\log n)\\). Compared to other search algorithms, it has a low time complexity. This article will introduce the basic idea of binary search and how to implement it.\nBasic Idea of Binary Search # In a nutshell: Divide and conquer until the target is found. Let\u0026rsquo;s start by analyzing the simplest case. Suppose we have an array \\(a_1,\\ldots,a_n\\) sorted in ascending order. If we want to find a specific number \\(a_i\\), the brute-force method would be to start from the first number and search one by one until we find the desired number. In the worst case, the target number is the last number, resulting in a time complexity of \\(O(n)\\) for this search.\nInstead, we can take out the middle number \\(a_{\\lfloor n/2 \\rfloor}\\) and compare it with the target \\(a_i\\). If the middle value is greater than the target value, since the array is sorted, the target value must be in the left half of the array. Otherwise, the target value must be in the right half of the array. This way, we narrow down the search range by half each time, and we can eventually find the target number. The time complexity of this search is \\(O(\\log n)\\).\nImplementation of Binary Search # The implementation of binary search is straightforward. We just need to translate the above idea into code, taking care of handling the boundary values. Here\u0026rsquo;s the code in Java:\npublic int search(int[] nums, int target) { int left = 0, right = nums.length; while(left \u0026lt; right) { // Excluding the right node, so initially right = nums.length-1+1 int middle = left + (right - left \u0026gt;\u0026gt; 1); // To prevent array overflow, bitwise operation is used instead of division by 2 for better efficiency (When does overflow occur?) if(nums[middle] \u0026gt; target) { // If the middle value is greater than the target value, the target value must be in the left half of the array right = middle; } else if(nums[middle] \u0026lt; target) { // If the middle value is less than the target value, the target value must be in the right half of the array left = middle + 1; } else { return middle; } } return -1; } ","date":"21 March 2023","permalink":"/algorithm/binarysearch/","section":"Algorithms","summary":"","title":"Binary Search"},{"content":"","date":null,"permalink":"/tags/binarysearch/","section":"Tags","summary":"","title":"BinarySearch"},{"content":"所有不包含在其他分类中的文章都会被归类到这里。\n","date":null,"permalink":"/others/","section":"其他","summary":"所有不包含在其他分类中的文章都会被归类到这里。","title":"其他"}]